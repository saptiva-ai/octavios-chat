#!/bin/bash
# ========================================
# BLUE/GREEN DEPLOYMENT SWITCHER
# ========================================
# Cambia el tráfico entre los stacks blue y green
# manteniendo zero-downtime.
#
# Workflow:
#   1. Detecta color activo actual
#   2. Verifica que el color idle esté saludable
#   3. Actualiza nginx/proxy para apuntar al nuevo color
#   4. Espera confirmación de health checks
#   5. Detiene el color anterior (ahora idle)
#   6. Guarda el nuevo color activo
#
# Usage:
#   ./scripts/blue-green-switch.sh [COLOR]
#
#   COLOR: blue|green|auto (default: auto detecta el idle)
#
# Examples:
#   ./scripts/blue-green-switch.sh           # Auto-switch al color idle
#   ./scripts/blue-green-switch.sh green     # Switch explícito a green
#   ./scripts/blue-green-switch.sh --status  # Ver estado actual

set -e
set -o pipefail

# ========================================
# CONFIGURATION
# ========================================
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
DEPLOY_STATE_DIR="${DEPLOY_STATE_DIR:-$PROJECT_ROOT/.deploy}"
CURRENT_COLOR_FILE="$DEPLOY_STATE_DIR/current_color"
NGINX_CONFIG="/etc/nginx/sites-available/copilotos"
NGINX_ENABLED="/etc/nginx/sites-enabled/copilotos"

RED="✖ "
GREEN="✔ "
YELLOW="▲ "
BLUE="▸ "

mkdir -p "$DEPLOY_STATE_DIR"

# ========================================
# LOGGING
# ========================================
log_info() { echo -e "${BLUE}$1"; }
log_success() { echo -e "${GREEN}$1"; }
log_warning() { echo -e "${YELLOW}$1"; }
log_error() { echo -e "${RED}$1" >&2; }

# ========================================
# COLOR DETECTION
# ========================================
get_current_color() {
    if [ -f "$CURRENT_COLOR_FILE" ]; then
        cat "$CURRENT_COLOR_FILE"
    else
        echo "none"
    fi
}

get_idle_color() {
    local current=$(get_current_color)
    case "$current" in
        blue) echo "green" ;;
        green) echo "blue" ;;
        none) echo "blue" ;; # Default to blue on first deploy
        *) echo "blue" ;;
    esac
}

get_target_color() {
    local arg="${1:-auto}"
    case "$arg" in
        blue|green) echo "$arg" ;;
        auto) get_idle_color ;;
        *) log_error "Invalid color: $arg"; exit 1 ;;
    esac
}

# ========================================
# HEALTH CHECKS
# ========================================
check_stack_health() {
    local color=$1
    local project="copilotos-$color"

    log_info "Checking health of $color stack..."

    # Verificar que los contenedores estén corriendo
    local running=$(docker compose -p "$project" -f "$PROJECT_ROOT/infra/docker-compose.app.yml" ps -q | wc -l)
    if [ "$running" -eq 0 ]; then
        log_error "$color stack is not running"
        return 1
    fi

    # Obtener puerto dinámico del API
    local api_port=$(docker port "$project-api-1" 8001 2>/dev/null | cut -d':' -f2 || echo "")
    if [ -z "$api_port" ]; then
        log_error "Cannot determine API port for $color stack"
        return 1
    fi

    # Health check HTTP
    if ! curl -sf "http://localhost:$api_port/api/health" > /dev/null; then
        log_error "$blue stack API health check failed"
        return 1
    fi

    # Verificar web si es necesario
    local web_port=$(docker port "$project-web-1" 3000 2>/dev/null | cut -d':' -f2 || echo "")
    if [ -n "$web_port" ]; then
        if ! curl -sf "http://localhost:$web_port/healthz" > /dev/null; then
            log_warning "$color stack Web health check failed (non-critical)"
        fi
    fi

    log_success "$color stack is healthy (API: $api_port)"
    return 0
}

# ========================================
# NGINX SWITCH
# ========================================
update_nginx_upstream() {
    local new_color=$1
    local project="copilotos-$new_color"

    log_info "Updating nginx upstream to $new_color..."

    # Obtener puertos dinámicos
    local api_port=$(docker port "$project-api-1" 8001 2>/dev/null | cut -d':' -f2)
    local web_port=$(docker port "$project-web-1" 3000 2>/dev/null | cut -d':' -f2)

    if [ -z "$api_port" ] || [ -z "$web_port" ]; then
        log_error "Cannot determine ports for $new_color stack"
        return 1
    fi

    # Generar configuración nginx temporal
    local temp_config=$(mktemp)
    cat > "$temp_config" << EOF
# Generated by blue-green-switch.sh
# Active color: $new_color
# API port: $api_port
# Web port: $web_port

upstream copilotos_api {
    server 127.0.0.1:$api_port;
}

upstream copilotos_web {
    server 127.0.0.1:$web_port;
}

server {
    listen 80;
    listen [::]:80;
    server_name _;

    # API Backend
    location /api/ {
        proxy_pass http://copilotos_api;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        # Timeouts
        proxy_read_timeout 300;
        proxy_connect_timeout 60;
        proxy_send_timeout 60;
    }

    # Frontend
    location / {
        proxy_pass http://copilotos_web;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        # Disable buffering for real-time
        proxy_buffering off;
        proxy_cache off;
    }

    # Health check endpoint
    location /health {
        access_log off;
        return 200 "OK - Active: $new_color\\n";
        add_header Content-Type text/plain;
    }
}
EOF

    # Validar configuración
    sudo nginx -t -c "$temp_config" 2>&1 | grep -q "successful" || {
        log_error "Nginx configuration validation failed"
        rm "$temp_config"
        return 1
    }

    # Aplicar configuración
    sudo cp "$temp_config" "$NGINX_CONFIG"
    sudo ln -sf "$NGINX_CONFIG" "$NGINX_ENABLED" 2>/dev/null || true
    sudo nginx -s reload

    rm "$temp_config"
    log_success "Nginx updated to route to $new_color stack"
    return 0
}

# ========================================
# SWITCH OPERATION
# ========================================
perform_switch() {
    local new_color=$1
    local old_color=$(get_current_color)

    echo ""
    log_info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    log_info "  Blue/Green Deployment Switch"
    log_info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    log_info "Current active: $old_color"
    log_info "Switching to:   $new_color"
    echo ""

    # Step 1: Verificar que el nuevo color esté saludable
    if ! check_stack_health "$new_color"; then
        log_error "Cannot switch: $new_color stack is not healthy"
        exit 1
    fi

    # Step 2: Actualizar nginx
    if ! update_nginx_upstream "$new_color"; then
        log_error "Failed to update nginx configuration"
        exit 1
    fi

    # Step 3: Verificar que el switch funcionó
    sleep 2
    if curl -sf http://localhost/api/health > /dev/null; then
        log_success "Traffic successfully routed to $new_color"
    else
        log_error "Health check failed after switch - ROLLING BACK"
        if [ "$old_color" != "none" ]; then
            update_nginx_upstream "$old_color"
        fi
        exit 1
    fi

    # Step 4: Guardar nuevo color activo
    echo "$new_color" > "$CURRENT_COLOR_FILE"
    log_success "Active color updated: $new_color"

    # Step 5: Detener el color anterior (opcional, para liberar recursos)
    if [ "$old_color" != "none" ] && [ "$old_color" != "$new_color" ]; then
        read -p "Stop $old_color stack? (y/N) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            log_info "Stopping $old_color stack..."
            docker compose -p "copilotos-$old_color" \
                -f "$PROJECT_ROOT/infra/docker-compose.app.yml" down
            log_success "$old_color stack stopped"
        else
            log_info "Keeping $old_color stack running (idle)"
        fi
    fi

    echo ""
    log_success "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    log_success "  Switch Complete!"
    log_success "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    log_info "Active color: $new_color"
    log_info "Idle color:   $(get_idle_color)"
    echo ""
}

# ========================================
# STATUS COMMAND
# ========================================
show_status() {
    local current=$(get_current_color)
    local idle=$(get_idle_color)

    echo ""
    echo "Blue/Green Deployment Status"
    echo "=============================="
    echo ""
    echo "Active color:  $current"
    echo "Idle color:    $idle"
    echo ""

    # Check both stacks
    for color in blue green; do
        local project="copilotos-$color"
        local running=$(docker compose -p "$project" -f "$PROJECT_ROOT/infra/docker-compose.app.yml" ps -q 2>/dev/null | wc -l)

        echo -n "$color stack:    "
        if [ "$running" -gt 0 ]; then
            if check_stack_health "$color" 2>/dev/null; then
                echo "[RUNNING + HEALTHY]"
            else
                echo "[RUNNING - UNHEALTHY]"
            fi
        else
            echo "[STOPPED]"
        fi
    done
    echo ""
}

# ========================================
# MAIN
# ========================================
main() {
    case "${1:-auto}" in
        --status|-s)
            show_status
            ;;
        --help|-h)
            cat << EOF
Blue/Green Deployment Switcher

Usage:
  $0 [COLOR]         Switch to specified color
  $0 --status        Show current status
  $0 --help          Show this help

Colors:
  auto    Auto-detect idle color (default)
  blue    Switch to blue stack
  green   Switch to green stack

Examples:
  $0                 # Auto-switch to idle color
  $0 green           # Switch to green
  $0 --status        # Show current status
EOF
            ;;
        *)
            local target=$(get_target_color "$1")
            perform_switch "$target"
            ;;
    esac
}

main "$@"
